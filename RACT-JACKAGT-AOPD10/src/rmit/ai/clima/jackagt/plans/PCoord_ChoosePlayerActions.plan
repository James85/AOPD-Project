package rmit.ai.clima.jackagt.plans;
import rmit.ai.clima.jackagt.events.*;
import rmit.ai.clima.jackagt.data.*;
import rmit.ai.clima.gui.grid.*;
import java.util.*;

public plan PCoord_ChoosePlayerActions extends Plan
{
   /******** Start PDT Design Block *** DO NOT EDIT IT *********/

   /*
Plan Name: PCoord_ChoosePlayerActions
    */
   //Events handled by the plan are declared here.
   #posts event EFindPath efindpath_p;

   #posts event EIdentifyTarget eidentifytarget_p;

   #sends event MEPlayerAction meplayeraction_s;

   #posts event EFindClosestGold efindclosestgold_p;

   #handles event EChoosePlayerActions echooseplayeractions_h;


   // Declarations of any beliefset/data that the plan accesses.
   #modifies data BPlayerPosition bel_playerTarget_dat;

   #reads data BObstacleAt bel_obstacleAt_dat;

   #reads data SimulationProp bel_simulationProp_dat;

   #reads data BPlayer bel_players_dat;

   #reads data BPlayerGold bel_playerGold_dat;

   #reads data BPlayerClosestGold bel_playerClosestGold_dat;

   #reads data BPlayerPosition bel_playerPositions_dat;

   #reads data BMoveHint bel_moveHint_dat;

   #reads data BGoldAt bel_goldAt_dat;

   /******** End PDT Design Block *** DO NOT EDIT IT *********/

   static boolean relevant(EChoosePlayerActions e)
   {
      return true;
   }
   context()
   {
      true;
   }

   final static String[] lookUpDirs = { "up", "down", "right", "left" };

   #reasoning method
   body()
   {
      logical int $depotX, $depotY;
      bel_simulationProp_dat.getDepotLoc( $depotX, $depotY );

      //Find the closest player-gold pairs
      @subtask(efindclosestgold_p.post());

      //Loop through all players on the team
      logical String $playerName;
      String baseName;
      Cursor c_players = bel_players_dat.get( $playerName );
      System.out.println(bel_goldAt_dat.nFacts());
      while (c_players.next())
      {
         logical int $x, $y;
         logical int $numGold;
         boolean goldFound = false;

         Cursor c_target;
         logical String $targetMove;
         logical int $targetX, $targetY;
         boolean haveTarget = false;

         baseName = $playerName.as_string();
         baseName = baseName.substring(0,baseName.indexOf("@"));

         //Get player info
         bel_playerPositions_dat.getByName( $playerName.as_string(), $x, $y );
         bel_playerGold_dat.getByName( $playerName.as_string(), $numGold );

         System.out.println($playerName.as_string() + " has : "+ $numGold.as_int());

         //Get player target if any
         if (bel_playerTarget_dat.getByName($playerName.as_string(), $targetX, $targetY ))
         {
            //Find path to current target
            System.out.println($playerName.as_string() + " has target "+ $targetX.as_int() + ", " + $targetY.as_int());
            @subtask(efindpath_p.post( $x.as_int(), $y.as_int(), $targetX.as_int(), $targetY.as_int() ));
            c_target = bel_moveHint_dat.getByEndPoints($x.as_int(), $y.as_int(), $targetX.as_int(), $targetY.as_int(), $targetMove );

            //Remove this target if unreachable
            if (!c_target.next()) {
               bel_playerTarget_dat.remove( $playerName.as_string(), $targetX.as_int(), $targetY.as_int() );
               System.out.println( "Dropping target - unreachable" );

            //Remove this target if as explored
            }else if( !bel_obstacleAt_dat.checkUnknown($targetX.as_int(), $targetY.as_int() )) {
               bel_playerTarget_dat.remove( $playerName.as_string(), $targetX.as_int(), $targetY.as_int() );
               System.out.println( "Dropping target - explored" );

            //Remove this target if reached
            }else if ($targetX.as_int() == $x.as_int() && $targetY.as_int() == $y.as_int()) {
               bel_playerTarget_dat.remove( $playerName.as_string(), $targetX.as_int(), $targetY.as_int() );
               System.out.println( "Dropping target - reached" );

            //Target is still valid
            }else {
               haveTarget = true;
               System.out.println($targetMove.as_string() + "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDd");
            }
         }

         //Check if we reached the depot
         if( $x.as_int() == $depotX.as_int() && $y.as_int() == $depotY.as_int() )
         {
            //Check if we got any gold
            if($numGold.as_int() > 0)
            {
               //Drop the gold
               @send( baseName, meplayeraction_s.send( "drop" ));
               if (haveTarget) bel_playerTarget_dat.remove( $playerName.as_string(), $targetX.as_int(), $targetY.as_int() );
               continue;
            }
         }

         // return to depot if we have our max carrying gold
         if($numGold.as_int() >= 1)
         {
            @subtask(efindpath_p.post( $x.as_int(), $y.as_int(), $depotX.as_int(), $depotY.as_int() ));
            logical String $move;

            if (bel_moveHint_dat.getByEndPoints($x.as_int(), $y.as_int(), $depotX.as_int(), $depotY.as_int(), $move ))
            {
               @send( baseName, meplayeraction_s.send( "moveTo", $move.as_string() ));
               if (haveTarget) bel_playerTarget_dat.remove( $playerName.as_string(), $targetX.as_int(), $targetY.as_int() );
            }
            continue;  
         }

         //Check if gold at current location
         if (bel_goldAt_dat.check( $x.as_int(), $y.as_int() ))
         {

            @send( baseName, meplayeraction_s.send( "pick" ));
            if (haveTarget) bel_playerTarget_dat.remove( $playerName.as_string(), $targetX.as_int(), $targetY.as_int() );
            continue;
         }

         //Check if theres a gold nearby
         logical int $goldX, $goldY;
         if (bel_playerClosestGold_dat.getByName( $playerName.as_string(), $goldX, $goldY ))
         {
            System.out.println($playerName.as_string() + ": my closest gold is ( " + $goldX.as_int() + ", " + $goldY.as_int() + ")");
            //Find path to that gold
            @subtask(efindpath_p.post( $x.as_int(), $y.as_int(), $goldX.as_int(), $goldY.as_int() ));
            //Move to path hinted direction
            logical String $move;

            if (bel_moveHint_dat.getByEndPoints($x.as_int(), $y.as_int(), $goldX.as_int(), $goldY.as_int(), $move ))
            {
               @send( baseName, meplayeraction_s.send( "moveTo", $move.as_string() ));
               if (haveTarget) bel_playerTarget_dat.remove( $playerName.as_string(), $targetX.as_int(), $targetY.as_int() );
            }
            continue;
         }

         //Check if target dropped
         if (!haveTarget)
         {
            //Try to find a new target
            while(true)
            {
               //choose a random unexplored point to move to and store it in a new beliefset
               logical int $tX, $tY;
               @subtask(eidentifytarget_p.post($playerName.as_string() ));
               bel_playerTarget_dat.getByName($playerName.as_string(), $tX, $tY);
               //if (!bel_playerTarget_dat.getByName($playerName.as_string(), $tX, $tY)) {
               //   System.out.println( "FAILED TO FIND UNEXPLORED" );
               //   break;
               //}

               System.out.println( "I AM EXPLORING " + $tX.as_int() + ", " + $tY.as_int() );
               @subtask(efindpath_p.post( $x.as_int(), $y.as_int(), $tX.as_int(), $tY.as_int() ));

               //Check if target reachable and find direction to move
               logical String $tMove;
               if (bel_moveHint_dat.getByEndPoints($x.as_int(), $y.as_int(), $tX.as_int(), $tY.as_int(), $tMove ))
               {
                  @send( baseName, meplayeraction_s.send( "moveTo", $tMove.as_string() ));
                  break;
               }
            }
         }
         else
         {
            //Keep moving towards current target
            @send( baseName, meplayeraction_s.send( "moveTo", $targetMove.as_string() ));
         }

      }//players loop


      //Clear the pathfinding results
      logical int $srcX, $srcY,  $dstX,  $dstY;
      logical String $dir;
      bel_moveHint_dat.get($srcX, $srcY, $dstX, $dstY, $dir).removeAll();

      logical String $profit;
      logical int $profitX, $profitY;
      System.out.println("REMOVING THIS MUCH GOLD: " + bel_playerClosestGold_dat.nFacts());
      bel_playerClosestGold_dat.get( $profit, $profitX, $profitY ).removeAll();
      System.out.println("THERE IS THIS MUCH GOLD LEFT: " + bel_playerClosestGold_dat.nFacts());


   }
}
