package rmit.ai.clima.jackagt.plans;
import rmit.ai.clima.jackagt.events.*;
import rmit.ai.clima.jackagt.data.*;
import rmit.ai.clima.gui.grid.*;
import java.util.*;
import aos.jack.util.cursor.*;

public plan PFindPath extends Plan
{
	/******** Start PDT Design Block *** DO NOT EDIT IT *********/

/*
Plan Name: PFindPath
*/
	//Events handled by the plan are declared here.
	#handles event EFindPath efindpath_h;


	// Declarations of any beliefset/data that the plan accesses.
	#modifies data BMoveHint bel_moveHint_dat;

	#reads data BObstacleAt bel_obstacleAt_dat;

	#reads data SimulationProp bel_simulationProp_dat;

	#reads data BPlayerPosition bel_playerPositions_dat;

/******** End PDT Design Block *** DO NOT EDIT IT *********/

	context()
	{
		
		true;
	}



	body()
	{
		logical int $width, $height;
		bel_simulationProp_dat.getGridSize( $width, $height );

		logical int $depotX, $depotY;
		bel_simulationProp_dat.getDepotLoc( $depotX, $depotY );
		GridPoint depotPoint = new GridPoint( $depotX.as_int(), $depotY.as_int() );

		int width = $width.as_int();
		int height = $height.as_int();
		GridPoint src = new GridPoint(efindpath_h.srcX, efindpath_h.srcY);
		GridPoint dst = new GridPoint(efindpath_h.dstX, efindpath_h.dstY);

		//Check for silly input
		if (src.equals(dst)) 
		{

			bel_moveHint_dat.add( src.x, src.y, dst.x, dst.y, "cur" );
			return true;
		}

		//Init obstacles
		PathGrid grid = new PathGrid( width,  height );

		for (int x=0; x<width; ++x) {
			for (int y=0; y<height; ++y) {

				PathNode node = grid.getNode( x, y ); 

				//Check if obstacle at this location
				if(bel_obstacleAt_dat.check( x, y ))
					node.obstacle = true;

				//Check if depot at this location (and not start or end point)
				if(node.pos.equals(depotPoint) && !node.pos.equals(src) && !node.pos.equals(dst))
					node.obstacle = true;

				//Check if any player at this location
				logical String $name;
				if (bel_playerPositions_dat.getByCoord( $name, x, y ))
					if (!$name.as_string().equals( efindpath_h.playerName ))
						node.obstacle = true;
			}
		}
		//Create and wait for a FindPathAction cursor to handle pathfinding in another thread.
		Cursor c_pathCursor = new FindPathAction( src, dst, grid);
		@wait_for(c_pathCursor);

		String moveDir = ((FindPathAction)c_pathCursor).getMoveDir();
		bel_moveHint_dat.add( src.x, src.y, dst.x, dst.y, moveDir );
		//System.out.println(efindpath_h.playerName);

	}

	class FindPathAction extends Action
	{
		String returnDir;
		PathNode root;
		Vector open;
		PathGrid grid;
		GridPoint src;
		GridPoint dst;
		Vector adjacentDir;
		boolean dstReached; 

		FindPathAction(GridPoint src, GridPoint dst, PathGrid grid)
		{
			//Init root node
			this.grid = grid;
			root = grid.getNode( src );
			root.dir = "";
			root.visited = true;
			this.src = src;
			this.dst = dst;
			this.adjacentDir = new Vector();
			this.dstReached = false;

			this.adjacentDir.add("left");
			this.adjacentDir.add("right");
			this.adjacentDir.add("up");
			this.adjacentDir.add("down");

			open = new Vector();
			open.add( root );
		}




		protected void action()
		{

			
			while (!open.isEmpty())
			{

				//Get next node with shortest path estimate
				PathNode cur = (PathNode)open.lastElement();
				open.remove( open.size() -1 );

				//Check if destination reached
				if (cur.pos.x == dst.x && cur.pos.y == dst.y) {
					dstReached = true;

					break;
				}

				
				//Loop through adjacent nodes
				Collections.shuffle(adjacentDir);
				for (int a=0; a<adjacentDir.size(); ++a)
				{
					//Get adjacent node
					GridPoint adjPos = cur.pos.getFromDir( (String)adjacentDir.get(a) );

					if(adjPos.x < 0 || adjPos.x >= grid.width || adjPos.y < 0 || adjPos.y >= grid.height)
						continue;

					PathNode adj = grid.getNode( adjPos );

					//Skip nodes with obstacles
					if (adj.obstacle) continue;

					//Calculate path status
					int g = cur.g + 1;
					int h = adj.pos.getManhattanDist( dst );
					int f = g + h;

					//Check we've been here before
					if (adj.visited)
					{

						//Check if the current path is shorter
						if (f < adj.f)
						{
							//It is so  route from adjacent back to current
							adj.dir = (String) (GridPoint.getRelativeDirections( adj.pos, cur.pos )[0]);
							adj.g = g;
							adj.h = h;
							adj.f = f;
						}
					}
					else
					{
						//Haven't so route from adjacent back to current
						adj.dir = (String) ( GridPoint.getRelativeDirections( adj.pos, cur.pos )[0] );
						adj.g = g;
						adj.h = h;
						adj.f = f;
						adj.visited = true;
						open.add( adj );
					}

				}//adjacent nodes

				Collections.sort( open );

			}//open

			if(dstReached)
			{
				PathNode dstNode = grid.getNode( dst );
				PathNode srcNode = grid.getNode( src );
				PathNode prevNode = dstNode;
				PathNode curNode = dstNode;

				while (true)
				{

					GridPoint prevPoint = curNode.pos.getFromDir(curNode.dir);
					prevNode = grid.getNode( prevPoint );
					if (prevNode == srcNode) break;
					curNode = prevNode;
				}


				this.returnDir = (String) ( prevNode.pos.getRelativeDirections( prevNode.pos, curNode.pos )[0] );

				//bel_moveHint_dat.add( src.x, src.y, dst.x, dst.y, moveDir );
			}
		}

		public String getMoveDir()
		{
			return returnDir;
		}
	}

	class PathGrid
	{
		public int width;
		public int height;
		PathNode [] grid;

		public PathGrid (int width, int height)
		{
			this.width = width;
			this.height = height;
			grid = new PathNode[ width * height ];

			for (int x=0; x<width; ++x) {
				for (int y=0; y<height; ++y) {

					PathNode node = new PathNode(); 
					node.pos.x = x;
					node.pos.y = y;
					grid[y * width + x] = node;
				}
			}
		}

		public PathNode getNode (int x, int y)
		{
			return grid[ y * width + x ];
		}

		public PathNode getNode (GridPoint pt)
		{
			return getNode( pt.x, pt.y );
		}
	}

	class PathNode implements Comparable
	{
		public boolean obstacle;
		public boolean visited;
		public GridPoint pos;
		public String dir;
		public int g;
		public int h;
		public int f;

		public PathNode ()
		{
			visited = false;
			obstacle = false;
			pos = new GridPoint();
			dir = "";
			g = 0;
			h = 0;
			f = 0;
		}

		public boolean equals (Object o)
		{
			PathNode other = (PathNode)o;
			return (f == other.f);
		}

		public int compareTo (Object o)
		{
			PathNode other = (PathNode)o;
			return other.f - f;
		}
	}
}
